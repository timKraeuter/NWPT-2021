% easychair.tex,v 3.5 2017/03/15

\documentclass[a4paper]{easychair}
%\documentclass[EPiC]{easychair}
%\documentclass[EPiCempty]{easychair}
%\documentclass[debug]{easychair}
%\documentclass[verbose]{easychair}
%\documentclass[notimes]{easychair}
%\documentclass[withtimes]{easychair}
%\documentclass[a4paper]{easychair}
%\documentclass[letterpaper]{easychair}

\usepackage{doc}

% use this if you have a long article and want to create an index
% \usepackage{makeidx}

% In order to save space or manage large tables or figures in a
% landcape-like text, you can use the rotating and pdflscape
% packages. Uncomment the desired from the below.
%
% \usepackage{rotating}
% \usepackage{pdflscape}

% Some of our commands for this guide.
%
\newcommand{\easychair}{\textsf{easychair}}
\newcommand{\miktex}{MiK{\TeX}}
\newcommand{\texniccenter}{{\TeX}nicCenter}
\newcommand{\makefile}{\texttt{Makefile}}
\newcommand{\latexeditor}{LEd}

%\makeindex

%% Front Matter
%%
% Regular title as in the article class.
%
\title{Heterogeneous behavioral model composition \\
        using graph grammars}

% Authors are joined by \and. Their affiliations are given by \inst, which indexes
% into the list defined using \institute
%
\author{
Tim Kräuter
}

% Institutes for affiliations are also joined by \and,
\institute{
  Høgskulen på Vestlandet\\
  Bergen, Norway\\
  \email{tkra@hvl.no}
 }

%  \authorrunning{} has to be set for the shorter version of the authors' names;
% otherwise a warning will be rendered in the running heads. When processed by
% EasyChair, this command is mandatory: a document without \authorrunning
% will be rejected by EasyChair

\authorrunning{Mokhov, Sutcliffe and Voronkov}

% \titlerunning{} has to be set to either the main title or its shorter
% version for the running heads. When processed by
% EasyChair, this command is mandatory: a document without \titlerunning
% will be rejected by EasyChair
\titlerunning{Heterogeneous behavioral model composition using graph grammars}

\usepackage{glossaries}

\newacronym{mde}{MDE}{Model-driven engineering}
\newacronym{bpmn}{BPMN}{Business Process Modeling Notation}
\newacronym{ct}{CT}{category theory}
\newacronym{uml}{UML}{Unified Modeling Language}
\newacronym{dsl}{DSL}{Domain Specific Language}
\newacronym{csp}{CSP}{Communication Sequential Processes}

\begin{document}

\maketitle
% 2-3 pages abstract wanted by NWPT

%------------------------------------------------------------------------------
\section{Introduction}
% Introduction/Motivation
A common approach to handle the increasing complexity of software systems is \gls{mde}.
\gls{mde} leads to a clear separation of concerns by modeling each aspect of a system separately \cite{franceModeldrivenDevelopmentComplex2007}.
However, these individual models must be composed if one wants to execute the system or argue about global properties \cite{kienzleUnifyingFrameworkHomogeneous2019}.

% Narrowing down
Our contribution addresses the problem of how the individual models can be composed into one model describing the entire software system, even if the used models are heterogeneous, i.e., do not conform to the same modeling language.
In particular, we address the composition of behavioral models since its structural counterpart has been the focus of a significant amount of research already, for example, in \cite{kienzleUnifyingFrameworkHomogeneous2019, klareCommonalitiesPreservingConsistency2019, stunkelComprehensiveSystemsFormal2021}.
We further limit the behavioral models to those describing discrete behavior such as finite state machines, \gls{bpmn} diagrams, process algebras, and Petri nets. % Untimed variants and only a subset of BPMN.

\section{Heterogeneous behavioral model composition}
We assume that each behavioral model describes a component of the overall system running independently and in parallel to other components as long as no relation to any other component is defined.
However, components, i.e., behavioral models, must interact to realize a meaningful composite system behavior.

% 1. Step: Relate models. We suggest 2 primitives to relate behavioral models: synchronous and asynchronous communication
% We support synchronous and asynchronous communication (currently without data).
Our approach supports two types of interactions between behavioral models: \textit{synchronous} and \textit{asynchronous} communication.
One can use synchronous communication to model that one component acquires a resource realized as a separate model since it is shared across the entire system.
Asynchronous communication can, for example, be used to model that two components communicate using a messaging system or by writing/consuming files in a shared file system.
Defining synchronous communication leads to two components becoming active simultaneously, while asynchronous communication only requires one component to be active. 

% make this a step to differentiate everything a bit better
Interactions among a set of behavioral models can then be defined using synchronous or asynchronous communication.
However, not any element in a behavioral model can be part of an interaction.
For example, it does not make sense to define that a state in a state machine should communicate with a transition in a Petri net since a state represents static information.
Consequently, only certain elements in each behavioral model, such as transitions in state machines and Petri nets, should be used when defining interactions between behavioral models.
One can achieve these restrictions by creating and aligning the metamodels of the respective behavioral models, as described in \cite{krauterBehavioralConsistencyHeterogeneous2021}.

% 2. Step: Translate the models to a semantic domain/base language and combine them according to the defined relations. We propose graph grammars. Explain how both primitive relations are implemented
% Each behavioral model has to be converted to a graph grammar (automatic algorithm based on the used modeling language).
% All graph grammars are merged respecting the communication specified between them. Describe how the merge happens. (Merged/parallel rules for synch and enriched rules for asynch).


% Communication can be added between the behavioral models (only between the elements aligned in the respective metamodels).




% Include the structural aspects to have multiple instances of a model without repeating it (if the same communication protocol is used between these models).

% This can be used to define hierarchical models (add some example here). State machine where a state is realised by an activity diagram or something like that.

% Overall system can be executed and properties can be checked on the state space generated by the graph grammar (link to my models paper for more information on how to do this in detail).

\section{Prototypical validation}
Use some github repo to implement an example of the whole fiesta in groove. Maybe the hierarchical composition.

\section{Related work}
\cite{krauterBehavioralConsistencyHeterogeneous2021}: my own work.
Tell what exactly is new in this abstract/presentation

\cite{kienzleUnifyingFrameworkHomogeneous2019}:
Parallels between event structures as their underlying formalism and my approach.
Try to argue why my approach might be better (including dataflow in the future, data can be modelled by graphs which we operate on and can exchange easily. Visualization of the execution is easier since GG operate directly in the source language, when checking properties visualizing counterexamples if properties are not fulfilled is also easier.)

\section{Acknowledgments} \label{sect:acks}
The author would like to thank his supervisors Adrian Rutle, Harald König, and Yngve Lamo for fruitful discussions about the topic.
\label{sect:bib}
\bibliographystyle{plain}
%\bibliographystyle{alpha}
%\bibliographystyle{unsrt}
%\bibliographystyle{abbrv}
\bibliography{bib}

%------------------------------------------------------------------------------
% Index
%\printindex

%------------------------------------------------------------------------------
\end{document}

